# CLUSTER

## 一、重算聚类中心Seed

### 1.超像素中心属性

| 超像素中心 |         | 超像素中心     |
| ---------- | ------- | -------------- |
| center     | (x,y)   | 在图像中的坐标 |
| color_info | (l,a,b) | 颜色           |
| id         | labels  | 超像素唯一标识 |
| no_pixels  |         | 超像素个数     |

```C++
struct spixel_info
		{
			Vector2f center;
			Vector4f color_info;
			int id;
			int no_pixels;
		};
```

## 二、连接矩阵E

### 1.并行计算

1. 按照Pixel并行；
2. 搜索Pixel周围9个像素点的labels;
3. 若找到与 中心点idx不同的labels，则认为两个超像素是相邻的；

## 三、相似度矩阵W

### 1.算法计算

1. 按照相邻关系计算两个超像素的相似度
2. 相似度必须大于一定阈值

### 2.计算公式

#### 2.1 CIE L*a*b↔ LθM

$$
θ^{'}= atan2(B,A) \qquad θ^{'}\in(-\pi,\pi]
$$

$$
\begin{equation}
θ=
\begin{cases}
 θ^{'}*180/\pi	& 	 {θ^{'} \geq  0}		\\
 θ^{'}*180/\pi+360	& 	 {θ^{'} <  0}
\end{cases}
\end{equation}
\qquad
θ\in[0,360)
$$

$$
m=   \sqrt{ A^2+B^2 } \qquad m\in[0,128\sqrt{2}]
$$

$$
l=L  \qquad l \in [0,100]
$$

```c++
_CPU_AND_GPU_CODE_ inline void lab2LThetaM_Raw(
	const gSLICr::Vector4f& pix_in,
	gSLICr::Vector4f& pix_out)
{
	const float Degree_360 = 360.0F;
	///////////////////////////////////////
	if (pix_in.A == pix_in.B && pix_in.B == 0) {
		pix_out.theta = 0;
	}else{
		const float theta_arc = atan2(pix_in.B, pix_in.A);//(-pi,pi]
		pix_out.theta = theta_arc / M_PI *180;

		if (pix_out.theta<0){
			
			pix_out.theta += Degree_360;

		}
		
	}
	///////////////////////////////////////
	pix_out.m = sqrt(pix_in.A*pix_in.A + pix_in.B*pix_in.B);
	///////////////////////////////////////
	pix_out.l = pix_in.L;
	///////////////////////////////////////
}
```



#### 2.2 相似度计算

##### 2.2.2  彩色黑白分开计算

$$
W(i,j)=\left\{
\begin{aligned}

1 &&     \left\{
\begin{aligned} 
 
 when &&
 |θ_{j}-θ_{i}|<θ_{th0}  \& \space
 |L_{j}-L_{i}|<L_{th0} &&
 if(M_{i}<M_{Cth}, M_{j}<M_{Cth})\\
 
 when &&
 |θ_{j}-θ_{i}|<θ_{th1}  \& \space
 |L_{j}-L_{i}|<L_{th1}  \& \space
 |M_{j}-M_{i}|<M_{th1} &&
 
 if(M_{i}\geq M_{Cth}, M_{j} \geq M_{Cth})\\
 
 if(i==j)
\end{aligned}
\right. \\

0 && otherwise \\

\end{aligned}
\right.
$$



## 四.聚类

### 1.算法

1. 利用相似度矩阵W生成聚类关系图；
2. 完成聚类；

### 2.算法步骤

#### 2.2.1 相似度矩阵W转换为三角矩阵

##### 相似度矩阵

$$
\begin{matrix}
   			&j_{0} & j_{1} & j_{2} & j_{3} &j_{4} & j_{...} & j_{n-1} &j_{n}	\\
  i_{0} 	& 1 & 0 & 1 & 0 & 0 & ... & 0 & 0\\
  i_{1} 	& 0 & 1 & 0 & 1 & 0 & ... & 0 & 0\\
  i_{2} 	& 1 & 0 & 1 & 0 & 0 & ... & 0 & 1\\
  i_{3} 	& 0 & 1 & 0 & 1 & 1 & ... & 0 & 1\\
  i_{4} 	& 0 & 0 & 0 & 1 & 1 & ... & 1 & 0\\
  i_{...} 	&...&...&...&...&...& ... &...&...\\
  i_{n-1}  	& 0 & 0 & 0 & 1 & 0 & ... & 1 & 0\\
  i_{n}  	& 0 & 0 & 1 & 1 & 0 & ... & 0 & 1\\
  \end{matrix} \tag{1}
$$

##### 三角矩阵

将右下角全部置零
$$
\begin{matrix}
   			&j_{0} & j_{1} & j_{2} & j_{3} &j_{4} & j_{...} & j_{n-1} &j_{n}	\\
  i_{0} 	& 1 & 0 & 1 & 0 & 0 & ... & 0 & 0\\
  i_{1} 	& 0 & 1 & 0 & 1 & 0 & ... & 0 & 0\\
  i_{2} 	& 0 & 0 & 1 & 0 & 0 & ... & 0 & 1\\
  i_{3} 	& 0 & 0 & 0 & 1 & 1 & ... & 0 & 1\\
  i_{4} 	& 0 & 0 & 0 & 0 & 1 & ... & 1 & 0\\
  i_{...} 	&...&...&...&...&...& ... &...&...\\
  i_{n-1}  	& 0 & 0 & 0 & 0 & 0 & ... & 1 & 0\\
  i_{n}  	& 0 & 0 & 0 & 0 & 0 & ... & 0 & 1\\
  \end{matrix} \tag{1}
$$

#### 2.2.1 完成聚类

对三角矩阵执行聚类算法
$$
\begin{matrix}
   			&j_{0} & j_{1} & j_{2} & j_{3} &j_{4} & j_{...} & j_{n-1} &j_{n}	\\
  i_{0} 	& 1 & 0 & 1 & 0 & 0 & ... & 0 & 0\\
  i_{1} 	& 0 & 1 & 0 & 1 & 0 & ... & 0 & 0\\
  i_{2} 	& 0 & 0 & 1 & 0 & 0 & ... & 0 & 1\\
  i_{3} 	& 0 & 0 & 0 & 1 & 1 & ... & 0 & 1\\
  i_{4} 	& 0 & 0 & 0 & 0 & 1 & ... & 1 & 0\\
  i_{...} 	&...&...&...&...&...& ... &...&...\\
  i_{n-1}  	& 0 & 0 & 0 & 0 & 0 & ... & 1 & 0\\
  i_{n}  	& 0 & 0 & 0 & 0 & 0 & ... & 0 & 1\\
  \end{matrix} \tag{1}
$$

##### 第一步：

从矩阵的第n行n列开始，搜索所有n列上为1的数组，如果第n列上为1的数组只有第n行，

如果是，则：
$$
a(n,n)=1
$$
否则
$$
a(n,n)=0
$$
，公式如下：
$$
a(n,n)= \left\{
\begin{aligned} 
 1 && 如果第n列上为1的数组只有第n行,则本次运算结束\\
 0 && otherwise\\
\end{aligned}
\right. \\
$$
如果

$$
a(n,n) = 0
$$
则对这些数组按照“行降序”的顺序将其各列（1、2、3……n）进行逻辑或运算，并将结果赋值给行号最小的数组中。列的或运算算法如下：
$$
a(i_{min},j_{n})=a(i_{min},j_{n})\bigcup...\bigcup a(n,j_{n}) \\
a(i_{min},j_{n-1})=a(i_{min},j_{n})\bigcup...\bigcup a(n,j_{n-1}) \\
......\\
a(i_{min},i_{min})=a(i_{min},j_{n})\bigcup...\bigcup a(n,j_{min})\\
$$
赋值运算：

$$
a(n,n)=0
$$
，本次运算结束。

##### 第二步：

从矩阵的第*n*-1行*n*-1列开始，搜索所有n-1列上为1的数组，如果第n列上为1的数组只有第n行，否则

$$
a(n-1,n-1)=0
$$
，公式如下：
$$
a(n-1,n \sim n-1)= \left\{\begin{aligned}  1 && 如果第n列上为1的数组只有第n行,则本次运算结束\\ 0 && otherwise\\\end{aligned}\right. \\
$$
如果

$$
a(n-1,n \sim n-1) = 0
$$
则对这些数组按照“行降序”的顺序将其各列（1、2、3……n-1）进行逻辑或运算，并将结果赋值给行号最小的数组中。列的或运算算法如下：
$$
a(i_{min},j_{n})=a(i_{min},j_{n-1})\bigcup...\bigcup a(n-1,j_{n-1}) \\a(i_{min},j_{n-1})=a(i_{min},j_{n-1})\bigcup...\bigcup a(n-1,j_{n-2}) \\......\\a(i_{min},j_{min})=a(i_{min},j_{n-1})\bigcup...\bigcup a(n-1,j_{min})\\
$$
赋值运算：

$$
a(n-1,n \sim n-1) = 0
$$
，本次运算结束。

##### 第三步：

以此类推，从矩阵的第i行j列开始，搜索所有i列上为1的数组，如果第i列上为1的数组只有第

i行，否则
$$
a(i,i)=0
$$
，公式如下：
$$
a(i,n \sim i)= \left\{\begin{aligned}  1 && 如果第n列上为1的数组只有第n行,则本次运算结束\\ 0 && otherwise\\\end{aligned}\right. \\
$$
如果

$$
a(i,n \sim i) = 0
$$
则对这些数组按照“行降序”的顺序将其各列（1、2、3……n）进行逻辑或运算，并将结果赋值给行号最小的数组中。列的或运算算法如下：
$$
a(i_{min},j_{n})=a(i_{min},j_{n})\bigcup...\bigcup a(i,j_{n-1}) \\a(i_{min},j_{n-1})=a(i_{min},j_{n})\bigcup...\bigcup a(i,j_{n-2}) \\......\\a(i_{min},j_{min})=a(i_{min},j_{n})\bigcup...\bigcup a(i,j_{min})\\
$$
赋值运算：

$$
a(i,n \sim n-i) = 0
$$
，本次运算结束。

##### 第四步：

根据以上的算法将三角矩阵的每一行都遍历一遍，得到如下矩阵：
$$
\begin{matrix}   			
		&j_{0} & j_{1} & j_{2} & j_{3} &j_{4} & j_{...} & j_{n-1} &j_{n}	\\
i_{0} 		& 1 & 0 & 1 & 0 & 0 & ... & 0 & 0\\
i_{1} 		& 0 & 1 & 0 & 1 & 0 & ... & 0 & 0\\
i_{2} 		& 0 & 0 & 1 & 0 & 0 & ... & 0 & 1\\
i_{3} 		& 0 & 0 & 0 & 0 & 1 & ... & 0 & 0\\
i_{4} 		& 0 & 0 & 0 & 0 & 0 & ... & 1 & 0\\
i_{...} 	&...&...&...&...&...& ... &...&...\\
i_{n-1}  	& 0 & 0 & 0 & 0 & 0 & ... & 0 & 0\\
i_{n}  		& 0 & 0 & 0 & 0 & 0 & ... & 0 & 0\\  
\end{matrix} \tag{1}
$$
则矩阵中所有非零的行数组即为聚类图块的数组。

