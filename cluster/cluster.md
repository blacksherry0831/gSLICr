# CLUSTER

## 一、重算聚类中心Seed

### 1.超像素中心属性

| 超像素中心 |         | 超像素中心     |
| ---------- | ------- | -------------- |
| center     | (x,y)   | 在图像中的坐标 |
| color_info | (l,a,b) | 颜色           |
| id         | labels  | 超像素唯一标识 |
| no_pixels  |         | 超像素个数     |

```C++
struct spixel_info
		{
			Vector2f center;
			Vector4f color_info;
			int id;
			int no_pixels;
		};
```

## 二、连接矩阵E

### 1.并行计算

1. 按照Pixel并行；
2. 搜索Pixel周围9个像素点的labels;
3. 若找到与 中心点idx不同的labels，则认为两个超像素是相邻的；

## 三、相似度矩阵W

### 1.算法计算

1. 按照相邻关系计算两个超像素的相似度
2. 相似度必须大于一定阈值

### 2.计算公式

#### 2.1 CIE L*a*b↔ LθM

$$
θ= \frac{ atan2(B,A)}{(2 * PI)}+0.5
$$

$$
m=  \frac{ \sqrt{ A^2+B^2 }  }{ 128* \sqrt{2} }
$$

$$
l=\frac{L}{100}
$$

```C++
inline void ImageColorSpaceThetaML::ColorSpaceLab2ThetaML(
	const double L,
	const double A,
	const double B,
	double & _theta,
	double & _m,
	double & _l)
{
	const float LAB_M_MAX = 128 * 1.4142135623731;
	const float X2_PI = 2 * CV_PI;
	///////////////////////////////////////
	if (A == B && B == 0) {
		_theta = 0;
	}
	else
	{
		_theta = atan2(B, A);//(-pi,pi]
		_theta = _theta / X2_PI + 0.5F;
	}
	///////////////////////////////////////
	_m = sqrt(A*A + B*B);
	_m = _m / (LAB_M_MAX);
	///////////////////////////////////////
	_l = L / 100;
	///////////////////////////////////////
}
```

#### 2.2 相似度计算

##### 2.2.2  彩色黑白分开计算

$$
W(i,j)=\left\{
\begin{aligned}

1 &&     \left\{
\begin{aligned} 
 
 when &&
 |L_{j}-L_{i}|<L_{th} &&
 if(M_{i}<M_{Cth}, M_{j}<M_{Cth})\\
 
 when &&
 |θ_{j}-θ_{i}|<θ_{th}  \& \space
 |L_{j}-L_{i}|<L_{th}  \& \space
 |M_{j}-M_{i}|<M_{th} &&
 
 if(M_{i}\geq M_{Cth}, M_{j} \geq M_{Cth})\\
 
 if(i==j)
\end{aligned}
\right. \\

0 && otherwise \\

\end{aligned}
\right.
$$



## 四.聚类

### 1.算法

1. 利用相似度矩阵W生成聚类关系图；
2. 完成聚类；

### 2.算法步骤

#### 2.2.1 相似度矩阵W转换为三角矩阵

##### 相似度矩阵

$$
\begin{matrix}
   			&j_{0} & j_{1} & j_{2} & j_{3} &j_{4} & j_{...} & j_{n-1} &j_{n}	\\
  i_{0} 	& 1 & 0 & 1 & 0 & 0 & ... & 0 & 0\\
  i_{1} 	& 0 & 1 & 0 & 1 & 0 & ... & 0 & 0\\
  i_{2} 	& 1 & 0 & 1 & 0 & 0 & ... & 0 & 1\\
  i_{3} 	& 0 & 1 & 0 & 1 & 1 & ... & 0 & 1\\
  i_{4} 	& 0 & 0 & 0 & 1 & 1 & ... & 1 & 0\\
  i_{...} 	&...&...&...&...&...& ... &...&...\\
  i_{n-1}  	& 0 & 0 & 0 & 1 & 0 & ... & 1 & 0\\
  i_{n}  	& 0 & 0 & 1 & 1 & 0 & ... & 0 & 1\\
  \end{matrix} \tag{1}
$$

##### 三角矩阵

将右下角全部置零
$$
\begin{matrix}
   			&j_{0} & j_{1} & j_{2} & j_{3} &j_{4} & j_{...} & j_{n-1} &j_{n}	\\
  i_{0} 	& 1 & 0 & 1 & 0 & 0 & ... & 0 & 0\\
  i_{1} 	& 0 & 1 & 0 & 1 & 0 & ... & 0 & 0\\
  i_{2} 	& 0 & 0 & 1 & 0 & 0 & ... & 0 & 1\\
  i_{3} 	& 0 & 0 & 0 & 1 & 1 & ... & 0 & 1\\
  i_{4} 	& 0 & 0 & 0 & 0 & 1 & ... & 1 & 0\\
  i_{...} 	&...&...&...&...&...& ... &...&...\\
  i_{n-1}  	& 0 & 0 & 0 & 0 & 0 & ... & 1 & 0\\
  i_{n}  	& 0 & 0 & 0 & 0 & 0 & ... & 0 & 1\\
  \end{matrix} \tag{1}
$$

#### 2.2.1 完成聚类

对三角矩阵执行聚类算法
$$
\begin{matrix}
   			&j_{0} & j_{1} & j_{2} & j_{3} &j_{4} & j_{...} & j_{n-1} &j_{n}	\\
  i_{0} 	& 1 & 0 & 1 & 0 & 0 & ... & 0 & 0\\
  i_{1} 	& 0 & 1 & 0 & 1 & 0 & ... & 0 & 0\\
  i_{2} 	& 0 & 0 & 1 & 0 & 0 & ... & 0 & 1\\
  i_{3} 	& 0 & 0 & 0 & 1 & 1 & ... & 0 & 1\\
  i_{4} 	& 0 & 0 & 0 & 0 & 1 & ... & 1 & 0\\
  i_{...} 	&...&...&...&...&...& ... &...&...\\
  i_{n-1}  	& 0 & 0 & 0 & 0 & 0 & ... & 1 & 0\\
  i_{n}  	& 0 & 0 & 0 & 0 & 0 & ... & 0 & 1\\
  \end{matrix} \tag{1}
$$

##### 第一步：

从矩阵的第n行n列开始，搜索所有n列上为1的数组，如果第n列上为1的数组只有第n行，否则

$$
a(n,n)=0
$$
，公式如下：
$$
a(n,n)= \left\{
\begin{aligned} 
 1 && 如果第n列上为1的数组只有第n行,则本次运算结束\\
 0 && otherwise\\
\end{aligned}
\right. \\
$$
如果

$$
a(n,n) \neq 0
$$
则对这些数组按照“行降序”的顺序将其各列（1、2、3……n）进行逻辑或运算，并将结果赋值给行号最小的数组中。列的或运算算法如下：
$$
a(i_{min},j_{n})=a(i_{min},j_{n})\bigcup...\bigcup a(n,j_{n}) \\
a(i_{min},j_{n-1})=a(i_{min},j_{n})\bigcup...\bigcup a(n,j_{n-1}) \\
......\\
a(i_{min},j_{min})=a(i_{min},j_{n})\bigcup...\bigcup a(n,j_{min})\\
$$
赋值运算：

$$
a(n,n)=0
$$
，本次运算结束。

##### 第二步：

从矩阵的第*n*-1行*n*-1列开始，搜索所有n-1列上为1的数组，如果第n列上为1的数组只有第n行，否则

$$
a(n,n)=0
$$
，公式如下：
$$
a(n-1,n \sim n-1)= \left\{\begin{aligned}  1 && 如果第n列上为1的数组只有第n行,则本次运算结束\\ 0 && otherwise\\\end{aligned}\right. \\
$$
如果

$$
a(n-1,n \sim n-1) \neq 0
$$
则对这些数组按照“行降序”的顺序将其各列（1、2、3……n-1）进行逻辑或运算，并将结果赋值给行号最小的数组中。列的或运算算法如下：
$$
a(i_{min},j_{n})=a(i_{min},j_{n-1})\bigcup...\bigcup a(n-1,j_{n-1}) \\a(i_{min},j_{n-1})=a(i_{min},j_{n-1})\bigcup...\bigcup a(n-1,j_{n-2}) \\......\\a(i_{min},j_{min})=a(i_{min},j_{n-1})\bigcup...\bigcup a(n-1,j_{min})\\
$$
赋值运算：

$$
a(n-1,n \sim n-1) = 0
$$
，本次运算结束。

##### 第三步：

以此类推，从矩阵的第i行j列开始，搜索所有i列上为1的数组，如果第i列上为1的数组只有第

i行，否则
$$
a(i,n \sim i)=0
$$
，公式如下：
$$
a(i,n \sim i)= \left\{\begin{aligned}  1 && 如果第n列上为1的数组只有第n行,则本次运算结束\\ 0 && otherwise\\\end{aligned}\right. \\
$$
如果

$$
a(i,n \sim i) \neq 0
$$
则对这些数组按照“行降序”的顺序将其各列（1、2、3……n）进行逻辑或运算，并将结果赋值给行号最小的数组中。列的或运算算法如下：
$$
a(i_{min},j_{n})=a(i_{min},j_{n})\bigcup...\bigcup a(i,j_{n-1}) \\a(i_{min},j_{n-1})=a(i_{min},j_{n})\bigcup...\bigcup a(i,j_{n-2}) \\......\\a(i_{min},j_{min})=a(i_{min},j_{n})\bigcup...\bigcup a(i,j_{min})\\
$$
赋值运算：

$$
a(i,n \sim n-i) = 0
$$
，本次运算结束。

##### 第四步：

根据以上的算法将三角矩阵的每一行都遍历一遍，得到如下矩阵：
$$
\begin{matrix}   			
		&j_{0} & j_{1} & j_{2} & j_{3} &j_{4} & j_{...} & j_{n-1} &j_{n}	\\
i_{0} 		& 1 & 0 & 1 & 0 & 0 & ... & 0 & 0\\
i_{1} 		& 0 & 1 & 0 & 1 & 0 & ... & 0 & 0\\
i_{2} 		& 0 & 0 & 0 & 0 & 0 & ... & 0 & 1\\
i_{3} 		& 0 & 0 & 0 & 0 & 1 & ... & 0 & 0\\
i_{4} 		& 0 & 0 & 0 & 0 & 0 & ... & 1 & 0\\
i_{...} 	&...&...&...&...&...& ... &...&...\\
i_{n-1}  	& 0 & 0 & 0 & 0 & 0 & ... & 0 & 0\\
i_{n}  		& 0 & 0 & 0 & 0 & 0 & ... & 0 & 0\\  
\end{matrix} \tag{1}
$$
则矩阵中所有非零的行数组即为聚类图块的数组。

